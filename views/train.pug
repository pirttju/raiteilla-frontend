extends layout

block content
  div#train-info(data-country=country data-train-number=trainNumber data-date=date)
    h1#train-title
      // The placeholder for the line ID badge, starts hidden
      span#line-id-badge.line-badge(style='display: none;')
      // The placeholder for the main title text
      span#train-title-text
    p#train-summary
  
  //- Container for the consist diagrams
  div#consist-container
  
  //- Button to toggle the map
  button#toggle-map-btn.map-toggle-button= t('toggleMap')
  
  //- The map starts hidden
  #map(style='height: 400px; margin-bottom: 20px; display: none;')

  table
    thead
      tr
        th= t('Station')
        th= t('Arrival')
        th= t('Departure')
        th= t('Platform')
        th= t('Status')
    tbody#schedule-body
      //- Schedule details will be populated by JavaScript

block scripts
  script.
    document.addEventListener('DOMContentLoaded', async () => {
      // --- Setup ---
      const trainInfo = document.getElementById('train-info');
      const { country, trainNumber, date } = trainInfo.dataset;
      const trainTitleText = document.getElementById('train-title-text');
      const trainSummary = document.getElementById('train-summary');
      const scheduleBody = document.getElementById('schedule-body');
      const timezoneMap = { fi: 'Europe/Helsinki', se: 'Europe/Stockholm', no: 'Europe/Oslo', gb: 'Europe/London' };
      const timezone = timezoneMap[country] || 'UTC';
      const trainApiUrl = `/train-api/v1/trains/${country}/${date}/${trainNumber}`;
      const lineColoursUrl = '/data/line_colours.json';

      // --- Helper Functions ---
      const formatTime = (isoString, tz) => { if (!isoString) return '–'; return new Date(isoString).toLocaleTimeString(navigator.language, { hour: '2-digit', minute: '2-digit', timeZone: tz }); };
      const displayTime = (scheduled, estimated, actual, tz) => { if (!scheduled) return '–'; const scheduledTime = formatTime(scheduled, tz); if (actual) { const actualTime = formatTime(actual, tz); if (actualTime !== scheduledTime) { return `<span class="actual">${actualTime}</span><br><s class="scheduled">${scheduledTime}</s>`; } return `<span class="actual">${actualTime}</span>`; } if (estimated) { const estimatedTime = formatTime(estimated, tz); if (estimatedTime !== scheduledTime) { return `<span class="estimated">${estimatedTime}</span><br><s class="scheduled">${scheduledTime}</s>`; } } return `<span>${scheduledTime}</span>`; };

      const getStatus = (stop) => {
        if (!stop || typeof stop !== 'object') {
          return '';
        }

        const hasArrival = !!stop.arrival;
        const hasDeparture = !!stop.departure;

        // Determine if the entire stop is effectively cancelled for a passenger.
        let isEffectivelyCancelled = false;
        if (hasArrival && stop.cancelled_arrival && hasDeparture && stop.cancelled_departure) {
          isEffectivelyCancelled = true; // Intermediate stop where both are cancelled.
        } else if (hasArrival && !hasDeparture && stop.cancelled_arrival) {
          isEffectivelyCancelled = true; // Terminating stop where arrival is cancelled.
        } else if (!hasArrival && hasDeparture && stop.cancelled_departure) {
          isEffectivelyCancelled = true; // Originating stop where departure is cancelled.
        }

        if (isEffectivelyCancelled) {
          return `<span class="status-cancelled">${window.i18n.cancelled}</span>`;
        }

        // If not fully cancelled, calculate delay based on the part of the stop that is still running.
        let finalTime = null;
        let scheduledTime = null;

        // Prioritize departure info if it exists and is not cancelled.
        if (hasDeparture && !stop.cancelled_departure) {
          if (stop.actual_departure) {
            finalTime = stop.actual_departure;
            scheduledTime = stop.departure;
          } else if (stop.estimated_departure) {
            finalTime = stop.estimated_departure;
            scheduledTime = stop.departure;
          }
        }
        // Otherwise, use arrival info if it exists and is not cancelled.
        else if (hasArrival && !stop.cancelled_arrival) {
          if (stop.actual_arrival) {
            finalTime = stop.actual_arrival;
            scheduledTime = stop.arrival;
          } else if (stop.estimated_arrival) {
            finalTime = stop.estimated_arrival;
            scheduledTime = stop.arrival;
          }
        }

        // If there's no real-time data for the valid part of the stop, show nothing.
        if (!finalTime || !scheduledTime) {
          return '';
        }

        // Calculate and display the delay.
        const delay = Math.floor((new Date(finalTime) - new Date(scheduledTime)) / 60000);
        if (delay >= 5) {
          return `<span class="status-delayed">${window.i18n.delayed} ${delay} ${window.i18n.minutes}</span>`;
        } else {
          return `<span class="status-ontime">${window.i18n.onTime}</span>`;
        }
      };

      const fetchAndRenderConsist = async (trainType, stationNameMap) => {
        const consistContainer = document.getElementById('consist-container');
        const allocationsApiUrl = `/train-api/v1/allocations/${country}/${date}/${trainNumber}`;
        try {
          const response = await fetch(allocationsApiUrl);
          const result = await response.json();
          if (!result.success || result.data.length === 0) return;
          const finnishSpecialSalesNumbers = ['999', '998', '997', '996', '995'];
          result.data.forEach(allocation => {
            const section = document.createElement('div'); section.className = 'consist-section';
            const beginName = stationNameMap[allocation.begin_station_short_code] || allocation.begin_station_short_code;
            const endName = stationNameMap[allocation.end_station_short_code] || allocation.end_station_short_code;
            const title = `<h2>${window.i18n.trainConsist} (${beginName}–${endName})</h2>`;
            const metaParts = [];

            if (allocation.total_length) {
              metaParts.push(`${window.i18n.totalLength}: ${allocation.total_length} m`);
            }
            if (allocation.maximum_speed > 0) {
              metaParts.push(`${window.i18n.maxSpeed}: ${allocation.maximum_speed} km/h`);
            }

            const meta = `<p class="consist-meta">${metaParts.join(' | ')}</p>`;
            const scrollContainer = document.createElement('div'); scrollContainer.className = 'consist-scroll-container';
            const isEmu = allocation.groups.every(group => group.vehicles.every(vehicle => vehicle.vehicle_type === 'wagon'));
            allocation.groups.forEach(group => {
              const groupDiv = document.createElement('div'); groupDiv.className = 'consist-group';
              const vehiclesWrapper = document.createElement('div'); vehiclesWrapper.className = 'vehicles-wrapper';
              group.vehicles.forEach((vehicle, index) => {
                const vehicleUnitDiv = document.createElement('div'); vehicleUnitDiv.className = 'vehicle-unit';
                let iconSrc = '';

                // Icon logic
                if (vehicle.vehicle_type === 'locomotive') {
                  iconSrc = '/images/locomotive.svg';
                } else {
                  // If the group has only one vehicle, it's a single unit (e.g., a railcar).
                  if (group.vehicles.length === 1) {
                    iconSrc = '/images/wagon_round.svg';
                  } else {
                    // Otherwise, use the existing logic for multi-vehicle sets.
                    const isFirst = index === 0;
                    const isLast = index === group.vehicles.length - 1;
                    if (isEmu) {
                      if (isFirst) { iconSrc = '/images/wagon_front.svg'; } 
                      else if (isLast) { iconSrc = '/images/wagon_rear.svg'; } 
                      else { iconSrc = '/images/wagon.svg'; }
                    } else {
                      let isControlCar = false;
                      if (country === 'gb' && vehicle.vehicle_number && vehicle.vehicle_number.startsWith('82')) { isControlCar = true; } 
                      else if (country === 'fi' && vehicle.vehicle_number === 'Edo') { isControlCar = true; }
                      
                      if (isControlCar) {
                        if (isFirst) { iconSrc = '/images/wagon_front.svg'; } 
                        else if (isLast) { iconSrc = '/images/wagon_rear.svg'; } 
                        else { iconSrc = '/images/wagon.svg'; }
                      } else {
                        iconSrc = '/images/wagon.svg';
                      }
                    }
                  }
                }

                const vehicleNumHtml = `<span class="vehicle-number">${vehicle.vehicle_number || ''}</span>`;
                const iconContainer = document.createElement('div'); iconContainer.className = 'vehicle-icon-container';
                const isFinnishSpecial = country === 'fi' && finnishSpecialSalesNumbers.includes(vehicle.sales_number);
                const isClosed = vehicle.sales_state === 'closed' || isFinnishSpecial;
                if (isClosed) { iconContainer.classList.add('is-closed'); }
                const iconHtml = `<img src="${iconSrc}" class="vehicle-icon" alt="${vehicle.vehicle_type}">`;
                const salesNumHtml = !isClosed && vehicle.sales_number ? `<span class="sales-number">${vehicle.sales_number}</span>` : '';
                iconContainer.innerHTML = iconHtml + salesNumHtml;
                vehicleUnitDiv.innerHTML = vehicleNumHtml; vehicleUnitDiv.appendChild(iconContainer);
                vehiclesWrapper.appendChild(vehicleUnitDiv);
              });
              groupDiv.appendChild(vehiclesWrapper);
              if (group.group_id) { const groupIdStr = String(group.group_id).trim(); if (groupIdStr.length > 0) { const groupIdSpan = document.createElement('span'); groupIdSpan.className = 'group-id'; groupIdSpan.textContent = groupIdStr; groupDiv.appendChild(groupIdSpan); } }
              scrollContainer.appendChild(groupDiv);
            });
            section.innerHTML = title + meta; section.appendChild(scrollContainer);
            consistContainer.appendChild(section);
          });
        } catch (error) { console.error('Failed to fetch train consist data:', error); }
      };

      // --- Main Execution Block ---
      try {
        const [trainResponse, coloursResponse] = await Promise.all([
          fetch(trainApiUrl).then(res => res.json()),
          fetch(lineColoursUrl).then(res => res.json())
        ]);
        
        const lineColoursData = coloursResponse;

        if (trainResponse.success && trainResponse.data.length > 0) {
          const train = trainResponse.data[0];
          
          if (train.line_no) {
            const lineBadge = document.getElementById('line-id-badge');
            lineBadge.textContent = train.line_no;
            const countryColours = lineColoursData[country];
            if (countryColours && countryColours[train.line_no]) {
              const colour = countryColours[train.line_no];
              lineBadge.style.backgroundColor = `#${colour}`;
            }
            lineBadge.style.display = 'inline-block';
          }
          
          const displayNumber = country === 'gb' && train.headcode ? train.headcode : train.train_number;
          const firstDeparture = formatTime(train.schedule[0].departure, timezone);
          trainTitleText.innerText = `${firstDeparture} ${train.origin_name}–${train.destination_name}`;
          trainSummary.innerText = `${train.train_type} ${displayNumber} | ${window.i18n.operator}: ${train.company}`;
          
          const stationNameMap = {};
          train.schedule.forEach(stop => { if (stop) stationNameMap[stop.station] = stop.name; });
          
          train.schedule.forEach(stop => {
            if (!stop || !stop.commercial_stop) return;
            const row = document.createElement('tr');
            const arrivalDisplay = displayTime(stop.arrival, stop.estimated_arrival, stop.actual_arrival, timezone);
            const departureDisplay = displayTime(stop.departure, stop.estimated_departure, stop.actual_departure, timezone);
            const status = getStatus(stop);
            row.innerHTML = `<td>${stop.name}</td><td>${arrivalDisplay}</td><td>${departureDisplay}</td><td>${stop.platform || '–'}</td><td>${status}</td>`;
            scheduleBody.appendChild(row);
          });
          
          fetchAndRenderConsist(train.train_type, stationNameMap);
          
          const mapContainer = document.getElementById('map');
          const toggleMapBtn = document.getElementById('toggle-map-btn');
          let mapInstance = null;
          toggleMapBtn.addEventListener('click', () => {
            const isHidden = mapContainer.style.display === 'none';
            mapContainer.style.display = isHidden ? 'block' : 'none';
            if (isHidden && !mapInstance) {
              mapInstance = initializeMap(train.schedule);
            }
          });

        } else {
          document.getElementById('train-title').innerText = 'Train not found.';
        }
      } catch (error) {
        console.error('Failed to fetch train data:', error);
        document.getElementById('train-title').innerText = 'Error loading data.';
      }
    });

    function initializeMap(schedule) {
      const coordinates = schedule.filter(stop => stop && stop.coordinates).map(stop => [stop.coordinates[0], stop.coordinates[1]]);
      if (coordinates.length < 2) return null;
      const map = new maplibregl.Map({ container: 'map', style: 'https://sv1.raiteilla.fi/maps/osm-light/style.json', center: coordinates[0], zoom: 6 });
      map.on('load', () => {
        const route = { type: 'Feature', geometry: { type: 'LineString', coordinates: coordinates } };
        map.addSource('route', { type: 'geojson', data: route });
        map.addLayer({ id: 'route-layer', type: 'line', source: 'route', layout: { 'line-join': 'round', 'line-cap': 'round' }, paint: { 'line-color': '#007cff', 'line-width': 4 } });
        const stations = { type: 'FeatureCollection', features: schedule.filter(stop => stop && stop.coordinates).map(stop => ({ type: 'Feature', geometry: { type: 'Point', coordinates: [stop.coordinates[0], stop.coordinates[1]] }, properties: { name: stop.name } })) };
        map.addSource('stations', { type: 'geojson', data: stations });
        map.addLayer({ id: 'stations-layer', type: 'circle', source: 'stations', paint: { 'circle-radius': 6, 'circle-color': '#ffffff', 'circle-stroke-color': '#007cff', 'circle-stroke-width': 2 } });
        const bounds = new maplibregl.LngLatBounds();
        coordinates.forEach(coord => bounds.extend(coord));
        map.fitBounds(bounds, { padding: 50 });
      });
      return map;
    }