extends layout

block content
  // The h1's data- attributes are critical for passing server data to the client script.
  h1#station-title(data-country=country data-station=station data-date=date)= `${t('Timetable for')} ${station}`

  // This div is the placeholder for the station's metadata (Identifier, Kilometer Marker, etc.)
  div#station-details.station-meta

  // Date navigation buttons
  div.date-navigation
    button#prev-day-btn= t('Previous day')
    button#next-day-btn= t('Next day')

  table
    thead
      tr
        th= t('Train')
        th= t('Origin')
        th= t('Destination')
        th= t('Arrival')
        th= t('Departure')
        th= t('Platform')
        th= t('Status')
    tbody#timetable-body
      //- Timetable rows will be populated by the script below

  p#no-trains-message(style='display: none;')= t('No trains scheduled today.')

block scripts
  script.
    document.addEventListener('DOMContentLoaded', async () => {
      const stationTitle = document.getElementById('station-title');
      const detailsContainer = document.getElementById('station-details');
      const { country, station: stationCode, date } = stationTitle.dataset;
      
      const timetableBody = document.getElementById('timetable-body');
      const noTrainsMessage = document.getElementById('no-trains-message');

      // Button and Navigation Logic
      const prevDayBtn = document.getElementById('prev-day-btn');
      const nextDayBtn = document.getElementById('next-day-btn');

      // Helper function to format a Date object to 'YYYY-MM-DD'
      const formatDate = (date) => date.toISOString().split('T')[0];

      // Use UTC to avoid timezone issues when calculating dates
      const currentDate = new Date(`${date}T00:00:00Z`);

      const prevDay = new Date(currentDate);
      prevDay.setUTCDate(currentDate.getUTCDate() - 1);
      const prevDateStr = formatDate(prevDay);

      const nextDay = new Date(currentDate);
      nextDay.setUTCDate(currentDate.getUTCDate() + 1);
      const nextDateStr = formatDate(nextDay);
      
      // Add event listeners to navigate
      prevDayBtn.addEventListener('click', () => {
        window.location.href = `/station/${country}/${stationCode}/${prevDateStr}`;
      });

      nextDayBtn.addEventListener('click', () => {
        window.location.href = `/station/${country}/${stationCode}/${nextDateStr}`;
      });

      const timetableApiUrl = `/train-api/v1/stations/${country}/${stationCode}/${date}`;
      const stationInfoApiUrl = `/train-api/v1/stations/${country}/${stationCode}`;

      const timezoneMap = { fi: 'Europe/Helsinki', se: 'Europe/Stockholm', no: 'Europe/Oslo', gb: 'Europe/London' };
      const timezone = timezoneMap[country] || 'UTC';
      const formatTime = (isoString, tz) => { if (!isoString) return '—'; return new Date(isoString).toLocaleTimeString(navigator.language, { hour: '2-digit', minute: '2-digit', timeZone: tz }); };
      const displayTime = (scheduled, estimated, actual, tz) => { if (!scheduled) return '—'; const scheduledTime = formatTime(scheduled, tz); if (actual) { const actualTime = formatTime(actual, tz); if (actualTime !== scheduledTime) { return `<span class="actual">${actualTime}</span><br><s class="scheduled">${scheduledTime}</s>`; } return `<span class="actual">${actualTime}</span>`; } if (estimated) { const estimatedTime = formatTime(estimated, tz); if (estimatedTime !== scheduledTime) { return `<span class="estimated">${estimatedTime}</span><br><s class="scheduled">${scheduledTime}</s>`; } } return `<span>${scheduledTime}</span>`; };

      const getStatus = (stop) => {
        // If stop is null or not an object, show nothing.
        if (!stop || typeof stop !== 'object') {
          return '';
        }

        // A train is terminating if it's scheduled to arrive but not depart.
        const isTerminatingTrain = stop.arrival && !stop.departure;

        // Show "Cancelled" if the departure is cancelled...
        if (stop.cancelled_departure) {
          return `<span class="status-cancelled">${window.i18n.cancelled}</span>`;
        }
        // ...or if it's a terminating train and its arrival is cancelled.
        if (isTerminatingTrain && stop.cancelled_arrival) {
          return `<span class="status-cancelled">${window.i18n.cancelled}</span>`;
        }

        // Determine the most definitive real-time data available.
        let finalTime = null;
        let scheduledTime = null;
        if (stop.actual_departure && stop.departure) { finalTime = stop.actual_departure; scheduledTime = stop.departure; } 
        else if (stop.actual_arrival && stop.arrival) { finalTime = stop.actual_arrival; scheduledTime = stop.arrival; } 
        else if (stop.estimated_departure && stop.departure) { finalTime = stop.estimated_departure; scheduledTime = stop.departure; } 
        else if (stop.estimated_arrival && stop.arrival) { finalTime = stop.estimated_arrival; scheduledTime = stop.arrival; }

        // If NO real-time data was found, show nothing.
        if (!finalTime || !scheduledTime) {
          return '';
        }

        // If we have real-time data, calculate the delay.
        const delay = Math.floor((new Date(finalTime) - new Date(scheduledTime)) / 60000);

        // Apply the 5-minute tolerance window.
        if (delay >= 5) {
          return `<span class="status-delayed">${window.i18n.delayed} ${delay} ${window.i18n.minutes}</span>`;
        } else {
          // If real-time data exists and delay is < 5 mins, show "On time".
          return `<span class="status-ontime">${window.i18n.onTime}</span>`;
        }
      };

      try {
        const [timetableResponse, stationInfoResponse] = await Promise.all([
          fetch(timetableApiUrl).then(res => res.json()),
          fetch(stationInfoApiUrl).then(res => res.json())
        ]);

        if (stationInfoResponse.success && stationInfoResponse.data) {
          const stationInfo = stationInfoResponse.data;
          const codeInBrackets = stationInfo.commercial_code || stationInfo.station;
          const newTitle = `${window.i18n.timetableFor} ${stationInfo.name} (${codeInBrackets})`;
          stationTitle.innerText = newTitle;
          document.title = newTitle;
          const detailsParts = [];
          if (stationInfo.country_code && stationInfo.primary_code) { detailsParts.push(`<strong>${window.i18n.stationIdentifier}:</strong> ${stationInfo.country_code}${stationInfo.primary_code}`); }
          if (stationInfo.km_m) { detailsParts.push(`<strong>${window.i18n.kilometerMarker}:</strong> ${stationInfo.km_m}`); }
          detailsContainer.innerHTML = detailsParts.join(' | ');
        }

        if (timetableResponse.success && timetableResponse.data.length > 0) {
          timetableResponse.data.forEach(train => {
            if (!train) return; // Guard clause for null entries

            const row = document.createElement('tr');
            const displayNumber = country === 'gb' && train.headcode ? train.headcode : train.train_number;
            const arrivalDisplay = displayTime(train.arrival, train.estimated_arrival, train.actual_arrival, timezone);
            const departureDisplay = displayTime(train.departure, train.estimated_departure, train.actual_departure, timezone);
            const status = getStatus(train);

            row.innerHTML = `
              <td><a href="/train/${country}/${train.train_number}/${train.departure_date}">${train.train_type} ${displayNumber}</a></td>
              <td>${train.origin_name}</td>
              <td>${train.destination_name}</td>
              <td>${arrivalDisplay}</td>
              <td>${departureDisplay}</td>
              <td>${train.platform || '–'}</td>
              <td>${status}</td>
            `;
            timetableBody.appendChild(row);
          });
        } else {
          noTrainsMessage.style.display = 'block';
        }
      } catch (error) {
        console.error('Failed to fetch station data:', error);
        stationTitle.innerText = 'Error loading data';
        timetableBody.innerHTML = '<tr><td colspan="7">Error loading timetable.</td></tr>';
      }
    });